

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Proc文件系统的实现 &mdash; Guojunos 1.0.0 文档</title>
  

  
  
    <link rel="shortcut icon" href="../_static/gj.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/guojun.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Guojunos
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">课程信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../course/slides.html">1. 课件资料</a></li>
<li class="toctree-l1"><a class="reference internal" href="../course/book.html">2. 使用教材</a></li>
<li class="toctree-l1"><a class="reference internal" href="../course/software.html">3. 所需软件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../course/schedule.html">4. 上课时间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../course/report.html">5. 实验报告</a></li>
</ul>
<p class="caption"><span class="caption-text">课程实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../experiments/introduction.html">1. 实验环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/VMware.html">2. 虚拟机环境安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/BochsInstall.html">3. Bochs 安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/Linux000setup.html">4. Linux 0.00</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/Linux011setup.html">5. Linux 0.11 on Ubuntu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/Linux011Use.html">6. Linux 0.11 的使用方法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/Linux011Flow.html">7. Linux 0.11 的工作模式</a></li>
</ul>
<p class="caption"><span class="caption-text">Intel手册读书笔记</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Intelx86/chap02.html">1. x86系统架构概览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Intelx86/chap03.html">2. 保护模式内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Intelx86/chap04.html">3. 中断和异常处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Intelx86/chap05.html">4. 任务管理</a></li>
</ul>
<p class="caption"><span class="caption-text">Linux 0.00 实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../linux000/linux000.html">1. 实验目的</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux000/linux000.html#id3">2. 实验内容</a></li>
</ul>
<p class="caption"><span class="caption-text">Linux 0.11 实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../linux011/lab01.html">1. 操作系统的引导</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux011/lab02.html">2. 系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux011/lab03.html">3. 进程运行轨迹的跟踪与统计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux011/lab04.html">4. 信号量的实现和应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux011/lab05.html">5. 地址映射与共享</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux011/lab06.html">6. 打印进程地址转换过程</a></li>
</ul>
<p class="caption"><span class="caption-text">附录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/BIOS.html">1. 中断向量表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/Bochs.html">2. Bochs 手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/FAQ.html">3. FAQ</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Guojunos</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Proc文件系统的实现</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="proc">
<h1>Proc文件系统的实现<a class="headerlink" href="#proc" title="永久链接至标题">¶</a></h1>
<p>难度系数：★★★☆☆</p>
<div class="section" id="id1">
<h2>实验目的<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>掌握虚拟文件系统的实现原理</p></li>
<li><p>实践文件、目录、索引节点等概念</p></li>
</ul>
</div>
<div class="section" id="id2">
<h2>实验内容<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>在Linux 0.11上实现 <code class="docutils literal notranslate"><span class="pre">procfs</span></code> （ <code class="docutils literal notranslate"><span class="pre">proc</span></code> 文件系统）内的 <code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 结点。当读取此结点的内容时，可得到系统当前所有进程的状态信息。例如，用 <code class="docutils literal notranslate"><span class="pre">cat</span></code> 命令显示 <code class="docutils literal notranslate"><span class="pre">/proc/psinfo</span></code> 的内容，可得到：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># cat /proc/psinfo</span>
<span class="n">pid</span>    <span class="n">state</span>    <span class="n">father</span>    <span class="n">counter</span>    <span class="n">start_time</span>
<span class="mi">0</span>    <span class="mi">1</span>    <span class="o">-</span><span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">28</span>    <span class="mi">1</span>
<span class="mi">4</span>    <span class="mi">1</span>    <span class="mi">1</span>    <span class="mi">1</span>    <span class="mi">73</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">1</span>    <span class="mi">27</span>    <span class="mi">63</span>
<span class="mi">6</span>    <span class="mi">0</span>    <span class="mi">4</span>    <span class="mi">12</span>    <span class="mi">817</span>
<span class="c1"># cat /proc/hdinfo</span>
<span class="n">total_blocks</span><span class="p">:</span><span class="mi">62000</span><span class="p">;</span>
<span class="n">free_blocks</span><span class="p">:</span><span class="mi">39037</span><span class="p">;</span>
<span class="n">used_blocks</span><span class="p">:</span><span class="mi">22963</span><span class="p">;</span>
<span class="n">total_inodes</span><span class="p">:</span><span class="mi">20666</span><span class="p">;</span>
<span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">procfs</span></code> 及其结点要在内核启动时自动创建。相关功能实现在 <code class="docutils literal notranslate"><span class="pre">fs/proc.c</span></code> 文件内。</p>
</div>
<div class="section" id="id3">
<h2>实验报告<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>完成实验后，在实验报告中回答如下问题：</p>
<ul class="simple">
<li><p>如果要求你在 <code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 之外再实现另一个结点，具体内容自选，那么你会实现一个给出什么信息的结点？为什么？</p></li>
<li><p>一次 <code class="docutils literal notranslate"><span class="pre">read()</span></code> 未必能读出所有的数据，需要继续 <code class="docutils literal notranslate"><span class="pre">read()</span></code> ，直到把数据读空为止。而数次 <code class="docutils literal notranslate"><span class="pre">read()</span></code> 之间，进程的状态可能会发生变化。你认为后几次 <code class="docutils literal notranslate"><span class="pre">read()</span></code> 传给用户的数据，应该是变化后的，还是变化前的？</p></li>
<li><p>如果是变化后的，那么用户得到的数据衔接部分是否会有混乱？如何防止混乱？</p></li>
<li><p>如果是变化前的，那么该在什么样的情况下更新 <code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 的内容？</p></li>
<li><p>删除文件以后， <code class="docutils literal notranslate"><span class="pre">/proc/inodeinfo</span></code> 那个 <code class="docutils literal notranslate"><span class="pre">inode</span></code> 号的 <code class="docutils literal notranslate"><span class="pre">inode</span></code> ，你发现了什么，为什么会这样？</p></li>
</ul>
<div class="section" id="id4">
<h3>评分标准<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>自动创建 <code class="docutils literal notranslate"><span class="pre">/proc</span></code> , <code class="docutils literal notranslate"><span class="pre">/proc/psinfo</span></code> ; <code class="docutils literal notranslate"><span class="pre">/proc/hdinfo</span></code> ; <code class="docutils literal notranslate"><span class="pre">/proc/inodeinfo</span></code> ，20%</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 内容可读，内容符合题目要求，40%</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hdinfo</span></code> 内容可读，符合题目要求，30%</p></li>
<li><p>实验报告，10%</p></li>
</ul>
</div>
</div>
<div class="section" id="id5">
<h2>实验提示<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<div class="section" id="procfs">
<h3>procfs简介<a class="headerlink" href="#procfs" title="永久链接至标题">¶</a></h3>
<p>正式的Linux内核实现了 <code class="docutils literal notranslate"><span class="pre">procfs</span></code> ，它是一个虚拟文件系统，通常被 <code class="docutils literal notranslate"><span class="pre">mount</span></code> 到 <code class="docutils literal notranslate"><span class="pre">/proc</span></code> 目录上，通过虚拟文件和虚拟目录的方式提供访问系统参数的机会，所以有人称它为“了解系统信息的一个窗口”。
这些虚拟的文件和目录并没有真实地存在在磁盘上，而是内核中各种数据的一种直观表示。
虽然是虚拟的，但它们都可以通过标准的系统调用（ <code class="docutils literal notranslate"><span class="pre">open()</span></code> 、 <code class="docutils literal notranslate"><span class="pre">read()</span></code> 等）访问。</p>
<p>例如， <code class="docutils literal notranslate"><span class="pre">/proc/meminfo</span></code> 中包含内存使用的信息，可以用cat命令显示其内容：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat /proc/meminfo
MemTotal:       384780 kB
MemFree:         13636 kB
Buffers:         13928 kB
Cached:         101680 kB
SwapCached:        132 kB
Active:         207764 kB
Inactive:        45720 kB
SwapTotal:      329324 kB
SwapFree:       329192 kB
Dirty:               0 kB
Writeback:           0 kB
……
</pre></div>
</div>
<p>其实，Linux的很多系统命令就是通过读取 <code class="docutils literal notranslate"><span class="pre">/proc</span></code> 实现的。例如 <code class="docutils literal notranslate"><span class="pre">uname</span> <span class="pre">-a</span></code>
的部分信息就来自 <code class="docutils literal notranslate"><span class="pre">/proc/version</span></code> ，而 <code class="docutils literal notranslate"><span class="pre">uptime</span></code> 的部分信息来自 <code class="docutils literal notranslate"><span class="pre">/proc/uptime</span></code> 和 <code class="docutils literal notranslate"><span class="pre">/proc/loadavg</span></code> 。</p>
<p>关于 <code class="docutils literal notranslate"><span class="pre">procfs</span></code> 更多的信息请访问：<a class="reference external" href="http://en.wikipedia.org/wiki/Procfs">http://en.wikipedia.org/wiki/Procfs</a></p>
</div>
<div class="section" id="id6">
<h3>基本思路<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>Linux是通过文件系统接口实现 <code class="docutils literal notranslate"><span class="pre">procfs</span></code> ，并在启动时自动将其 <code class="docutils literal notranslate"><span class="pre">mount</span></code> 到 <code class="docutils literal notranslate"><span class="pre">/proc</span></code> 目录上。此目录下的所有内容都是随着系统的运行自动建立、删除和更新的，而且它们完全存在于内存中，不占用任何外存空间。</p>
<p>Linux 0.11还没有实现虚拟文件系统，也就是，还没有提供增加新文件系统支持的接口。
所以本实验只能在现有文件系统的基础上，通过打补丁的方式模拟一个 <code class="docutils literal notranslate"><span class="pre">procfs</span></code> 。</p>
<p>Linux 0.11使用的是 <code class="docutils literal notranslate"><span class="pre">Minix</span></code> 的文件系统，这是一个典型的基于 <code class="docutils literal notranslate"><span class="pre">inode</span></code> 的文件系统，《注释》一书对它有详细描述。
它的每个文件都要对应至少一个 <code class="docutils literal notranslate"><span class="pre">inode</span></code> ，而 <code class="docutils literal notranslate"><span class="pre">inode</span></code> 中记录着文件的各种属性，包括文件类型。
文件类型有普通文件、目录、字符设备文件和块设备文件等。
在内核中，每种类型的文件都有不同的处理函数与之对应。我们可以增加一种新的文件类型—— <code class="docutils literal notranslate"><span class="pre">proc</span></code> 文件，并在相应的处理函数内实现 <code class="docutils literal notranslate"><span class="pre">procfs</span></code> 要实现的功能。</p>
</div>
<div class="section" id="id7">
<h3>增加新文件类型<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">include/sys/stat.h</span></code> 文件中定义了几种文件类型和相应的测试宏：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#define S_IFMT  00170000</span>
<span class="cp">#define S_IFREG  0100000    </span><span class="c1">//普通文件</span>
<span class="cp">#define S_IFBLK  0060000    </span><span class="c1">//块设备</span>
<span class="cp">#define S_IFDIR  0040000    </span><span class="c1">//目录</span>
<span class="cp">#define S_IFCHR  0020000    </span><span class="c1">//字符设备</span>
<span class="cp">#define S_IFIFO  0010000</span>
<span class="c1">// ……</span>

<span class="cp">#define S_ISREG(m)      (((m) &amp; S_IFMT) == S_IFREG)    </span><span class="c1">//测试m是否是普通文件</span>
<span class="cp">#define S_ISDIR(m)      (((m) &amp; S_IFMT) == S_IFDIR)    </span><span class="c1">//测试m是否是目录</span>
<span class="cp">#define S_ISCHR(m)      (((m) &amp; S_IFMT) == S_IFCHR)    </span><span class="c1">//测试m是否是字符设备</span>
<span class="cp">#define S_ISBLK(m)      (((m) &amp; S_IFMT) == S_IFBLK)    </span><span class="c1">//测试m是否是块设备</span>
<span class="cp">#define S_ISFIFO(m)     (((m) &amp; S_IFMT) == S_IFIFO)</span>
</pre></div>
</div>
<p>增加新的类型的方法分两步：</p>
<ul class="simple">
<li><p>定义一个类型宏 <code class="docutils literal notranslate"><span class="pre">S_IFPROC</span></code> ，其值应在 <code class="docutils literal notranslate"><span class="pre">0010000</span></code> 到 <code class="docutils literal notranslate"><span class="pre">0100000</span></code> 之间，但后四位八进制数必须是 <code class="docutils literal notranslate"><span class="pre">0</span></code> （这是 <code class="docutils literal notranslate"><span class="pre">S_IFMT</span></code> 的限制，分析测试宏可知原因），而且不能和已有的任意一个 <code class="docutils literal notranslate"><span class="pre">S_IFXXX</span></code> 相同；</p></li>
<li><p>定义一个测试宏 <code class="docutils literal notranslate"><span class="pre">S_ISPROC(m)</span></code> ，形式仿照其它的 <code class="docutils literal notranslate"><span class="pre">S_ISXXX(m)</span></code></p></li>
</ul>
<p>注意，C语言中以 <code class="docutils literal notranslate"><span class="pre">0</span></code> 直接接数字的常数是八进制数。</p>
</div>
<div class="section" id="mknod">
<h3>让mknod()支持新的文件类型<a class="headerlink" href="#mknod" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 结点要通过 <code class="docutils literal notranslate"><span class="pre">mknod()</span></code> 系统调用建立，所以要让它支持新的文件类型。
直接修改 <code class="docutils literal notranslate"><span class="pre">fs/namei.c</span></code> 文件中的 <code class="docutils literal notranslate"><span class="pre">sys_mknod()</span></code> 函数中的一行代码，如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISPROC</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>文件系统初始化<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>内核初始化的全部工作是在 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 中完成，而 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 在最后从内核态切换到用户态，并调用 <code class="docutils literal notranslate"><span class="pre">init()</span></code> 。 <code class="docutils literal notranslate"><span class="pre">init()</span></code> 做的第一件事情就是挂载根文件系统：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ……</span>
    <span class="n">setup</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">drive_info</span><span class="p">);</span>
    <span class="c1">// ……</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">procfs</span></code> 的初始化工作应该在根文件系统挂载之后开始。它包括两个步骤：</p>
<ul class="simple">
<li><p>建立 <code class="docutils literal notranslate"><span class="pre">/proc</span></code> 目录；</p></li>
<li><p>建立 <code class="docutils literal notranslate"><span class="pre">/proc</span></code> 目录下的各个结点。本实验只建立 <code class="docutils literal notranslate"><span class="pre">/proc/psinfo</span></code> 。</p></li>
</ul>
<p>建立目录和结点分别需要调用 <code class="docutils literal notranslate"><span class="pre">mkdir()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">mknod()</span></code> 系统调用。因为初始化时已经在用户态，所以不能直接调用 <code class="docutils literal notranslate"><span class="pre">sys_mkdir()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys_mknod()</span></code> 。必须在初始化代码所在文件中实现这两个系统调用的用户态接口，即 <code class="docutils literal notranslate"><span class="pre">API</span></code> ：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span>
<span class="cpf">#define __LIBRARY__</span><span class="cp"></span>
<span class="cp">#include</span>

<span class="cpf">_syscall2(int,mkdir,const char*,name,mode_t,mode)</span><span class="cp"></span>
<span class="n">_syscall3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">mknod</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="kt">mode_t</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="kt">dev_t</span><span class="p">,</span><span class="n">dev</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mkdir()</span></code> 时 <code class="docutils literal notranslate"><span class="pre">mode</span></code> 参数的值可以是 <code class="docutils literal notranslate"><span class="pre">0755</span></code> （ <code class="docutils literal notranslate"><span class="pre">rwxr-xr-x</span></code> ），表示只允许 <code class="docutils literal notranslate"><span class="pre">root</span></code> 用户改写此目录，其它人只能进入和读取此目录。</p>
<p><code class="docutils literal notranslate"><span class="pre">procfs</span></code> 是一个只读文件系统，所以用 <code class="docutils literal notranslate"><span class="pre">mknod()</span></code> 建立 <code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 结点时，必须通过 <code class="docutils literal notranslate"><span class="pre">mode</span></code> 参数将其设为只读。建议使用 <code class="docutils literal notranslate"><span class="pre">S_IFPROC|0444</span></code> 做为 <code class="docutils literal notranslate"><span class="pre">mode</span></code> 值，表示这是一个 <code class="docutils literal notranslate"><span class="pre">proc</span></code> 文件，权限为 <code class="docutils literal notranslate"><span class="pre">0444</span></code> （ <code class="docutils literal notranslate"><span class="pre">r--r--r--</span></code> ），对所有用户只读。</p>
<p><code class="docutils literal notranslate"><span class="pre">mknod()</span></code> 的第三个参数 <code class="docutils literal notranslate"><span class="pre">dev</span></code> 用来说明结点所代表的设备编号。对于 <code class="docutils literal notranslate"><span class="pre">procfs</span></code> 来说，此编号可以完全自定义。 <code class="docutils literal notranslate"><span class="pre">proc</span></code> 文件的处理函数将通过这个编号决定对应文件包含的信息是什么。例如，可以把 <code class="docutils literal notranslate"><span class="pre">0</span></code> 对应 <code class="docutils literal notranslate"><span class="pre">psinfo</span></code> ， <code class="docutils literal notranslate"><span class="pre">1</span></code> 对应 <code class="docutils literal notranslate"><span class="pre">meminfo</span></code> ， <code class="docutils literal notranslate"><span class="pre">2</span></code> 对应 <code class="docutils literal notranslate"><span class="pre">cpuinfo</span></code> 。</p>
<p>如此项工作完成得没有问题，那么编译、运行0.11内核后，用 <code class="docutils literal notranslate"><span class="pre">ll</span> <span class="pre">/proc</span></code> 可以看到：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># ll /proc
total 0
?r--r--r--   1 root     root              0 ??? ??  ???? psinfo
</pre></div>
</div>
<p>此时可以试着读一下此文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># cat /proc/psinfo</span>
<span class="p">(</span><span class="n">Read</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="o">=</span><span class="n">XXX444</span>
<span class="n">cat</span><span class="p">:</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">psinfo</span><span class="p">:</span> <span class="n">EINVAL</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">inode-&gt;i_mode</span></code> 就是通过 <code class="docutils literal notranslate"><span class="pre">mknod()</span></code> 设置的 <code class="docutils literal notranslate"><span class="pre">mode</span></code> 。信息中的 <code class="docutils literal notranslate"><span class="pre">XXX</span></code> 和你设置的 <code class="docutils literal notranslate"><span class="pre">S_IFPROC</span></code> 有关。通过此值可以了解 <code class="docutils literal notranslate"><span class="pre">mknod()</span></code> 工作是否正常。这些信息说明内核在对 <code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 进行读操作时不能正确处理，向 <code class="docutils literal notranslate"><span class="pre">cat</span></code> 返回了 <code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> 错误。因为还没有实现处理函数，所以这是很正常的。</p>
<p>这些信息至少说明， <code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 被正确 <code class="docutils literal notranslate"><span class="pre">open()</span></code> 了。所以我们不需要对 <code class="docutils literal notranslate"><span class="pre">sys_open()</span></code> 动任何手脚，唯一要打补丁的，是 <code class="docutils literal notranslate"><span class="pre">sys_read()</span></code> 。</p>
</div>
<div class="section" id="id9">
<h3>让proc文件可读<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">open()</span></code> 没有变化，那么需要修改的就是 <code class="docutils literal notranslate"><span class="pre">sys_read()</span></code> 了。首先分析 <code class="docutils literal notranslate"><span class="pre">sys_read</span></code> （在文件 <code class="docutils literal notranslate"><span class="pre">fs/read_write.c</span></code> 中）：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">sys_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">m_inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">;</span>
    <span class="c1">// ……</span>
    <span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_inode</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span><span class="n">read_pipe</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">)</span><span class="o">:-</span><span class="n">EIO</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rw_char</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">,</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">block_read</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_zone</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">file_read</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">file</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">count</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printk</span><span class="p">(</span><span class="s">&quot;(Read)inode-&gt;i_mode=%06o</span><span class="se">\n\r</span><span class="s">&quot;</span><span class="p">,</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>    <span class="c1">//这条信息很面善吧？</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>显然，要在这里一群 <code class="docutils literal notranslate"><span class="pre">if</span></code> 的排比中，加上 <code class="docutils literal notranslate"><span class="pre">S_IFPROC()</span></code> 的分支，进入对 <code class="docutils literal notranslate"><span class="pre">proc</span></code> 文件的处理函数。需要传给处理函数的参数包括：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">inode-&gt;i_zone[0]</span></code> ，这就是 <code class="docutils literal notranslate"><span class="pre">mknod()</span></code> 时指定的 <code class="docutils literal notranslate"><span class="pre">dev</span></code> ——设备编号</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">buf</span></code> ，指向用户空间，就是 <code class="docutils literal notranslate"><span class="pre">read()</span></code> 的第二个参数，用来接收数据</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">count</span></code> ，就是 <code class="docutils literal notranslate"><span class="pre">read()</span></code> 的第三个参数，说明 <code class="docutils literal notranslate"><span class="pre">buf</span></code> 指向的缓冲区大小</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&amp;file-&gt;f_pos</span></code> ， <code class="docutils literal notranslate"><span class="pre">f_pos</span></code> 是上一次读文件结束时“文件位置指针”的指向。这里必须传指针，因为处理函数需要根据传给 <code class="docutils literal notranslate"><span class="pre">buf</span></code> 的数据量修改 <code class="docutils literal notranslate"><span class="pre">f_pos</span></code> 的值。</p></li>
</ul>
</div>
<div class="section" id="id10">
<h3>proc文件的处理函数<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">proc</span></code> 文件的处理函数的功能是根据设备编号，把不同的内容写入到用户空间的 <code class="docutils literal notranslate"><span class="pre">buf</span></code> 。写入的数据要从 <code class="docutils literal notranslate"><span class="pre">f_pos</span></code> 指向的位置开始，每次最多写 <code class="docutils literal notranslate"><span class="pre">count</span></code> 个字节，并根据实际写入的字节数调整 <code class="docutils literal notranslate"><span class="pre">f_pos</span></code> 的值，最后返回实际写入的字节数。当设备编号表明要读的是 <code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 的内容时，就要按照 <code class="docutils literal notranslate"><span class="pre">psinfo</span></code> 的形式组织数据。</p>
<p>实现此函数可能要用到如下几个函数：</p>
</div>
<div class="section" id="malloc-free">
<h3>malloc()和free()<a class="headerlink" href="#malloc-free" title="永久链接至标题">¶</a></h3>
<p>包含 <code class="docutils literal notranslate"><span class="pre">linux/kernel.h</span></code> 头文件后，就可以使用 <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">free()</span></code> 函数。它们是可以被核心态代码调用的，唯一的限制是一次申请的内存大小不能超过一个页面。</p>
</div>
<div class="section" id="sprintf">
<h3>sprintf()<a class="headerlink" href="#sprintf" title="永久链接至标题">¶</a></h3>
<p>Linux 0.11没有 <code class="docutils literal notranslate"><span class="pre">sprintf()</span></code> ，可以参考 <code class="docutils literal notranslate"><span class="pre">printf()</span></code> 自己实现一个，如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp"></span>
<span class="c1">// ……</span>
<span class="kt">int</span> <span class="nf">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
    <span class="n">i</span><span class="o">=</span><span class="n">vsprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cat">
<h3>cat命令<a class="headerlink" href="#cat" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">cat</span></code> 是Linux下的一个常用命令，功能是将文件的内容打印到标准输出。它核心实现大体如下：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">513</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;\0&#39;</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">nread</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">buf</span><span class="p">[</span><span class="n">nread</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
        <span class="n">puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="psinfo">
<h3>psinfo的内容<a class="headerlink" href="#psinfo" title="永久链接至标题">¶</a></h3>
<p>进程的信息就来源于内核全局结构数组 <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">task[NR_TASKS]</span></code> 中，具体读取细节可参照 <code class="docutils literal notranslate"><span class="pre">sched.c</span></code> 中的函数 <code class="docutils literal notranslate"><span class="pre">schedule()</span></code></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">LAST_TASK</span> <span class="p">;</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FIRST_TASK</span> <span class="p">;</span> <span class="o">--</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
        <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">+</span> <span class="cm">/*...*/</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="hdinfo">
<h3>hdinfo的内容<a class="headerlink" href="#hdinfo" title="永久链接至标题">¶</a></h3>
<p>硬盘总共有多少块，多少块空闲，有多少 <code class="docutils literal notranslate"><span class="pre">inode</span></code> 等信息都放在 <code class="docutils literal notranslate"><span class="pre">super</span></code> 块中， <code class="docutils literal notranslate"><span class="pre">super</span></code> 块可以通过 <code class="docutils literal notranslate"><span class="pre">get_super()</span></code> 函数获得，其中的信息可以借鉴如下代码。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">;</span>
<span class="n">sb</span><span class="o">=</span><span class="n">get_super</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dev</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
<span class="n">total_blocks</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_nzones</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">is_zmap_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bh</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_zmap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019-2020, Dr. GuoJun LIU. All Rights Reserved.

    </p>
  </div>
 
	<script type="text/javascript">
		document.write(unescape("%3Cspan id='cnzz_stat_icon_1278706363'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1278706363%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));	
	</script>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>