

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. 系统调用 &mdash; Guojunos 1.0.0 文档</title>
  

  
  
    <link rel="shortcut icon" href="../_static/gj.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/guojun.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="5. 进程运行轨迹的跟踪与统计" href="lab03.html" />
    <link rel="prev" title="3. 操作系统的引导" href="lab01.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Guojunos
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">课程信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../course/slides.html">1. 课件资料</a></li>
<li class="toctree-l1"><a class="reference internal" href="../course/book.html">2. 使用教材</a></li>
<li class="toctree-l1"><a class="reference internal" href="../course/software.html">3. 所需软件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../course/schedule.html">4. 上课时间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../course/report.html">5. 实验报告</a></li>
</ul>
<p class="caption"><span class="caption-text">课程实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../experiments/introduction.html">1. 实验环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/VMware.html">2. 虚拟机环境安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/BochsInstall.html">3. Bochs 安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/Linux000setup.html">4. Linux 0.00</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/Linux011Use.html">5. Linux 0.11 on Ubuntu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experiments/Linux011Flow.html">6. Linux 0.11 的工作模式</a></li>
</ul>
<p class="caption"><span class="caption-text">Intel手册读书笔记</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Intelx86/chap02.html">1. x86系统架构概览</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Intelx86/chap03.html">2. 保护模式内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Intelx86/chap04.html">3. 中断和异常处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Intelx86/chap05.html">4. 任务管理</a></li>
</ul>
<p class="caption"><span class="caption-text">Linux 实验</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux000/lab01.html">1. 调试分析 Linux 0.00 引导程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux000/lab02.html">2. 调试分析 Linux 0.00 多任务切换</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab01.html">3. 操作系统的引导</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. 系统调用</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">4.1. 实验目的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">4.2. 实验内容</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#iam">4.2.1. <code class="docutils literal notranslate"><span class="pre">iam()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#whoami">4.2.2. <code class="docutils literal notranslate"><span class="pre">whoami()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">4.2.3. 测试程序</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">4.3. 实验报告</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">4.3.1. 评分标准</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">4.4. 实验提示</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">4.4.1. 应用程序如何调用系统调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="#int-0x80">4.4.2. 从 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">0x80</span></code> 进入内核函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sys-iam-sys-whoami">4.4.3. 实现 <code class="docutils literal notranslate"><span class="pre">sys_iam()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys_whoami()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#makefile">4.4.4. 修改 <code class="docutils literal notranslate"><span class="pre">Makefile</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#printk">4.4.5. 用 <code class="docutils literal notranslate"><span class="pre">printk()</span></code> 调试内核</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">4.4.6. 编写测试程序</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">4.4.7. 在用户态和核心态之间传递数据</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">4.4.8. 运行脚本程序</a></li>
<li class="toctree-l3"><a class="reference internal" href="#errno">4.4.9. errno</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lab03.html">5. 进程运行轨迹的跟踪与统计</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab04.html">6. 信号量的实现和应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab05.html">7. 地址映射与共享</a></li>
<li class="toctree-l1"><a class="reference internal" href="lab06.html">8. 打印进程地址转换过程</a></li>
</ul>
<p class="caption"><span class="caption-text">附录</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../appendix/BIOS.html">1. 中断向量表</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/Bochs.html">2. Bochs 手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/gdb.html">3. GDB Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/FAQ.html">4. FAQ</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Guojunos</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>4. 系统调用</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>4. 系统调用<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>4.1. 实验目的<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><p>建立对系统调用接口的深入认识</p></li>
<li><p>掌握系统调用的基本过程</p></li>
<li><p>能完成系统调用的全面控制</p></li>
<li><p>为后续实验做准备</p></li>
</ul>
</div>
<div class="section" id="id3">
<h2>4.2. 实验内容<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>此次实验的基本内容是：在 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span></code> 上添加两个系统调用，并编写两个简单的应用程序测试它们。</p>
<div class="section" id="iam">
<h3>4.2.1. <code class="docutils literal notranslate"><span class="pre">iam()</span></code><a class="headerlink" href="#iam" title="永久链接至标题">¶</a></h3>
<p>第一个系统调用是 <code class="docutils literal notranslate"><span class="pre">iam()</span></code> ，其原型为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">iam</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>完成的功能是将字符串参数 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的内容拷贝到内核中保存下来。
要求 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的长度不能超过 <code class="docutils literal notranslate"><span class="pre">23</span></code> 个字符。返回值是拷贝的字符数。
如果 <code class="docutils literal notranslate"><span class="pre">name</span></code> 的字符个数超过了 <code class="docutils literal notranslate"><span class="pre">23</span></code> ，则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> ，并置 <code class="docutils literal notranslate"><span class="pre">errno</span></code> 为 <code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> 。</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">kernal/who.c</span></code> 中实现此系统调用。</p>
</div>
<div class="section" id="whoami">
<h3>4.2.2. <code class="docutils literal notranslate"><span class="pre">whoami()</span></code><a class="headerlink" href="#whoami" title="永久链接至标题">¶</a></h3>
<p>第二个系统调用是 <code class="docutils literal notranslate"><span class="pre">whoami()</span></code> ，其原型为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">whoami</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p>它将内核中由 <code class="docutils literal notranslate"><span class="pre">iam()</span></code> 保存的名字拷贝到 <code class="docutils literal notranslate"><span class="pre">name</span></code> 指向的用户地址空间中，
同时确保不会对 <code class="docutils literal notranslate"><span class="pre">name</span></code> 越界访存（ <code class="docutils literal notranslate"><span class="pre">name</span></code> 的大小由 <code class="docutils literal notranslate"><span class="pre">size</span></code> 说明）。
返回值是拷贝的字符数。如果 <code class="docutils literal notranslate"><span class="pre">size</span></code> 小于需要的空间，则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> ，并置 <code class="docutils literal notranslate"><span class="pre">errno</span></code> 为 <code class="docutils literal notranslate"><span class="pre">EINVAL</span></code> 。</p>
<p>也是在 <code class="docutils literal notranslate"><span class="pre">kernal/who.c</span></code> 中实现。</p>
</div>
<div class="section" id="id4">
<h3>4.2.3. 测试程序<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>运行添加过新系统调用的 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span></code> ，在其环境下编写两个测试程序 <code class="docutils literal notranslate"><span class="pre">iam.c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">whoami.c</span></code> 。最终的运行结果是：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><style type="text/css">
span.prompt1:before {
  content: "$ ";
}
</style><span class="prompt1">./iam guojunos</span>
<span class="prompt1">./whoami</span>
<span class="prompt1">guojunos</span>
</pre></div></div><p><img alt="图1 执行结果" src="../_images/lab02_whoami.png" /></p>
<p>图1 执行结果</p>
</div>
</div>
<div class="section" id="id5">
<h2>4.3. 实验报告<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>在实验报告中回答如下问题：</p>
<ul class="simple">
<li><p>从 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span></code> 现在的机制看，它的系统调用最多能传递几个参数？</p></li>
<li><p>你能想出办法来扩大这个限制吗？</p></li>
<li><p>用文字简要描述向 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span></code> 添加一个系统调用 <code class="docutils literal notranslate"><span class="pre">foo()</span></code> 的步骤。</p></li>
</ul>
<div class="section" id="id6">
<h3>4.3.1. 评分标准<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>将 <code class="docutils literal notranslate"><span class="pre">testlab2.c</span></code> 在修改过的 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span></code> 上编译运行，显示的结果即内核程序的得分。满分50%</p></li>
<li><p>只要至少一个新增的系统调用被成功调用，并且能和用户空间交换参数，可得满分</p></li>
<li><p>将脚本 <code class="docutils literal notranslate"><span class="pre">testlab2.sh</span></code> 在修改过的 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span></code> 上运行，显示的结果即应用程序的得分。满分30%</p></li>
<li><p>实验报告，20%</p></li>
</ul>
<p><img alt="图2 testlab2.c 运行结果" src="../_images/lab02_testlab2c.png" /></p>
<p>图2 <code class="docutils literal notranslate"><span class="pre">testlab2.c</span></code> 运行结果</p>
<p><img alt="图3 testlab2.sh 运行结果" src="../_images/lab02_testlab2sh.png" /></p>
<p>图3 <code class="docutils literal notranslate"><span class="pre">testlab2.sh</span></code> 运行结果</p>
</div>
</div>
<div class="section" id="id7">
<h2>4.4. 实验提示<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>首先，请将 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span></code> 的源代码恢复到原始状态。</p>
<p>《注释》的 <code class="docutils literal notranslate"><span class="pre">5.5</span></code> 节详细讲述了 <code class="docutils literal notranslate"><span class="pre">0.11</span></code> 如何处理系统调用，是非常有价值的参考。</p>
<p>操作系统实现系统调用的基本过程是：</p>
<ol class="arabic simple">
<li><p>应用程序调用库函数（ <code class="docutils literal notranslate"><span class="pre">API</span></code> ）；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">API</span></code> 将系统调用号存入 <code class="docutils literal notranslate"><span class="pre">EAX</span></code> ，然后通过中断调用使系统进入内核态；</p></li>
<li><p>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</p></li>
<li><p>系统调用完成相应功能，将返回值存入 <code class="docutils literal notranslate"><span class="pre">EAX</span></code> ，返回到中断处理函数；</p></li>
<li><p>中断处理函数返回到 <code class="docutils literal notranslate"><span class="pre">API</span></code> 中；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">API</span></code> 将 <code class="docutils literal notranslate"><span class="pre">EAX</span></code> 返回给应用程序。</p></li>
</ol>
<div class="section" id="id8">
<h3>4.4.1. 应用程序如何调用系统调用<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>在通常情况下，调用系统调用和调用一个普通的自定义函数在代码上并没有什么区别，
但调用后发生的事情有很大不同。
调用自定义函数是通过 <code class="docutils literal notranslate"><span class="pre">call</span></code> 指令直接跳转到该函数的地址，继续运行。
而调用系统调用，是调用系统库中为该系统调用编写的一个接口函数，
叫 <strong>API</strong> （Application Programming Interface）。
<code class="docutils literal notranslate"><span class="pre">API</span></code> 并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用，过程是：</p>
<ul class="simple">
<li><p>把系统调用的编号存入 <code class="docutils literal notranslate"><span class="pre">EAX</span></code></p></li>
<li><p>把函数参数存入其它通用寄存器</p></li>
<li><p>触发 <code class="docutils literal notranslate"><span class="pre">0x80</span></code> 号中断（ <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">0x80</span></code> ）</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">0.11</span></code> 的 <code class="docutils literal notranslate"><span class="pre">lib</span></code> 目录下有一些已经实现的 <code class="docutils literal notranslate"><span class="pre">API</span></code> 。
Linus编写它们的原因是在内核加载完毕后，会切换到用户模式下，做一些初始化工作，然后启动 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 。
而用户模式下的很多工作需要依赖一些系统调用才能完成，因此在内核中实现了这些系统调用的 <code class="docutils literal notranslate"><span class="pre">API</span></code> 。
我们不妨看看 <code class="docutils literal notranslate"><span class="pre">lib/close.c</span></code> ，研究一下 <code class="docutils literal notranslate"><span class="pre">close()</span></code> 的 <code class="docutils literal notranslate"><span class="pre">API</span></code> ：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#define __LIBRARY__</span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="n">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">close</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="n">fd</span><span class="p">)</span>
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">_syscall1</span></code> 是一个宏，在 <code class="docutils literal notranslate"><span class="pre">include/unistd.h</span></code> 中定义。将 <code class="docutils literal notranslate"><span class="pre">_syscall1(int,close,int,fd)</span></code> 进行宏展开，可以得到：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">long</span> <span class="n">__res</span><span class="p">;</span>
     <span class="n">__asm__</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">&quot;int $0x80&quot;</span>
         <span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">__res</span><span class="p">)</span>
         <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">__NR_close</span><span class="p">),</span><span class="s">&quot;b&quot;</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">fd</span><span class="p">)));</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">__res</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
         <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">__res</span><span class="p">;</span>
     <span class="n">errno</span> <span class="o">=</span> <span class="o">-</span><span class="n">__res</span><span class="p">;</span>
     <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这就是 <code class="docutils literal notranslate"><span class="pre">API</span></code> 的定义。
它先将宏 <code class="docutils literal notranslate"><span class="pre">__NR_close</span></code> 存入 <code class="docutils literal notranslate"><span class="pre">EAX</span></code> ，将参数 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 存入 <code class="docutils literal notranslate"><span class="pre">EBX</span></code> ，然后进行 <code class="docutils literal notranslate"><span class="pre">0x80</span></code> 中断调用。
调用返回后，从 <code class="docutils literal notranslate"><span class="pre">EAX</span></code> 取出返回值，存入 <code class="docutils literal notranslate"><span class="pre">__res</span></code> ，再通过对 <code class="docutils literal notranslate"><span class="pre">__res</span></code> 的判断决定传给API的调用者什么样的返回值。
其中 <code class="docutils literal notranslate"><span class="pre">__NR_close</span></code> 就是系统调用的编号，在 <code class="docutils literal notranslate"><span class="pre">include/unistd.h</span></code> 中定义：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#define __NR_close    6</span>
</pre></div>
</div>
<p>所以添加系统调用时需要修改 <code class="docutils literal notranslate"><span class="pre">include/unistd.h</span></code> 文件，使其包含 <code class="docutils literal notranslate"><span class="pre">__NR_whoami</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__NR_iam</span></code> 。而在应用程序中，要有：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#define __LIBRARY__                              </span><span class="cm">/* 有它，_syscall1等才有效。详见unistd.h */</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;                              /* 有它，编译器才能获知自定义的系统调用的编号 */</span><span class="cp"></span>
<span class="n">_syscall1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">iam</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>          <span class="cm">/* iam()在用户空间的接口函数 */</span>
<span class="n">_syscall2</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">whoami</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>    <span class="cm">/* whoami()在用户空间的接口函数 */</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">0.11</span></code> 环境下编译 <code class="docutils literal notranslate"><span class="pre">C</span></code> 程序，包含的头文件都在 <code class="docutils literal notranslate"><span class="pre">/usr/include</span></code> 目录下。
该目录下的 <code class="docutils literal notranslate"><span class="pre">unistd.h</span></code> 是标准头文件（它和 <code class="docutils literal notranslate"><span class="pre">0.11</span></code> 源码树中的 <code class="docutils literal notranslate"><span class="pre">unistd.h</span></code> 并不是同一个文件，虽然内容可能相同），
没有 <code class="docutils literal notranslate"><span class="pre">__NR_whoami</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__NR_iam</span></code> 两个宏，需要手工加上它们，也可以直接从修改过的 <code class="docutils literal notranslate"><span class="pre">0.11</span></code> 源码树中拷贝新的 <code class="docutils literal notranslate"><span class="pre">unistd.h</span></code> 过来。</p>
</div>
<div class="section" id="int-0x80">
<h3>4.4.2. 从 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">0x80</span></code> 进入内核函数<a class="headerlink" href="#int-0x80" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">0x80</span></code> 触发后，接下来就是内核的中断处理了。
先了解一下 <code class="docutils literal notranslate"><span class="pre">0.11</span></code> 处理 <code class="docutils literal notranslate"><span class="pre">0x80</span></code> 号中断的过程。</p>
<p>在内核初始化时，主函数（在 <code class="docutils literal notranslate"><span class="pre">init/main.c</span></code> 中，<code class="docutils literal notranslate"><span class="pre">Linux</span></code> 实验环境下是 <code class="docutils literal notranslate"><span class="pre">main()</span></code> ， <code class="docutils literal notranslate"><span class="pre">Windows</span></code> 下因编译器兼容性问题被换名为 <code class="docutils literal notranslate"><span class="pre">start()</span></code> ）调用了 <code class="docutils literal notranslate"><span class="pre">sched_init()</span></code> 初始化函数：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ……</span>
    <span class="n">time_init</span><span class="p">();</span>
    <span class="n">sched_init</span><span class="p">();</span>
    <span class="n">buffer_init</span><span class="p">(</span><span class="n">buffer_memory_end</span><span class="p">);</span>
    <span class="c1">// ……</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sched_init()</span></code> 在 <code class="docutils literal notranslate"><span class="pre">kernel/sched.c</span></code> 中定义为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">sched_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ……</span>
    <span class="n">set_system_gate</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span><span class="o">&amp;</span><span class="n">system_call</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">set_system_gate</span></code> 是个宏，在 <code class="docutils literal notranslate"><span class="pre">include/asm/system.h</span></code> 中定义为：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#define set_system_gate(n,addr) \</span>
<span class="cp">    _set_gate(&amp;idt[n],15,3,addr)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">_set_gate</span></code> 的定义是：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#define _set_gate(gate_addr,type,dpl,addr) \</span>
<span class="cp">__asm__ (&quot;movw %%dx,%%ax\n\t&quot; \</span>
<span class="cp">    &quot;movw %0,%%dx\n\t&quot; \</span>
<span class="cp">    &quot;movl %%eax,%1\n\t&quot; \</span>
<span class="cp">    &quot;movl %%edx,%2&quot; \</span>
<span class="cp">    : \</span>
<span class="cp">    : &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \</span>
<span class="cp">    &quot;o&quot; (*((char *) (gate_addr))), \</span>
<span class="cp">    &quot;o&quot; (*(4+(char *) (gate_addr))), \</span>
<span class="cp">    &quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000))</span>
</pre></div>
</div>
<p>虽然看起来挺麻烦，但实际上很简单，就是填写 <code class="docutils literal notranslate"><span class="pre">IDT</span></code> （中断描述符表），
将 <code class="docutils literal notranslate"><span class="pre">system_call</span></code> 函数地址写到 <code class="docutils literal notranslate"><span class="pre">0x80</span></code> 对应的中断描述符中，也就是在中断 <code class="docutils literal notranslate"><span class="pre">0x80</span></code> 发生后，
自动调用函数 <code class="docutils literal notranslate"><span class="pre">system_call</span></code> 。
具体细节请参考《注释》的第 <code class="docutils literal notranslate"><span class="pre">4</span></code> 章。</p>
<p>接下来看 <code class="docutils literal notranslate"><span class="pre">system_call</span></code> 。该函数纯汇编打造，定义在 <code class="docutils literal notranslate"><span class="pre">kernel/system_call.s</span></code> 中：</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="c"># ……</span>
<span class="nf">nr_system_calls</span> <span class="o">=</span> <span class="mi">72</span>        <span class="c">#这是系统调用总数。如果增删了系统调用，必须做相应修改</span>
<span class="c"># ……</span>
<span class="na">.globl</span> <span class="no">system_call</span>
<span class="na">.align</span> <span class="mi">2</span>
<span class="nl">system_call:</span>
    <span class="nf">cmpl</span> <span class="no">$nr_system_calls-1</span><span class="p">,</span><span class="nv">%eax</span> <span class="c">#检查系统调用编号是否在合法范围内</span>
    <span class="nf">ja</span> <span class="no">bad_sys_call</span>
    <span class="nf">push</span> <span class="nv">%ds</span>
    <span class="nf">push</span> <span class="nv">%es</span>
    <span class="nf">push</span> <span class="nv">%fs</span>
    <span class="nf">pushl</span> <span class="nv">%edx</span>
    <span class="nf">pushl</span> <span class="nv">%ecx</span>
    <span class="nf">pushl</span> <span class="nv">%ebx</span>        <span class="c"># push %ebx,%ecx,%edx，是传递给系统调用的参数</span>
    <span class="nf">movl</span> <span class="no">$0x10</span><span class="p">,</span><span class="nv">%edx</span>        <span class="c"># 让ds,es指向GDT，内核地址空间</span>
    <span class="nf">mov</span> <span class="nv">%dx</span><span class="p">,</span><span class="nv">%ds</span>
    <span class="nf">mov</span> <span class="nv">%dx</span><span class="p">,</span><span class="nv">%es</span>
    <span class="nf">movl</span> <span class="no">$0x17</span><span class="p">,</span><span class="nv">%edx</span>        <span class="c"># 让fs指向LDT，用户地址空间</span>
    <span class="nf">mov</span> <span class="nv">%dx</span><span class="p">,</span><span class="nv">%fs</span>
    <span class="nf">call</span> <span class="no">sys_call_table</span><span class="p">(,</span><span class="nv">%eax</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="nf">pushl</span> <span class="nv">%eax</span>
    <span class="nf">movl</span> <span class="no">current</span><span class="p">,</span><span class="nv">%eax</span>
    <span class="nf">cmpl</span> <span class="no">$0</span><span class="p">,</span><span class="no">state</span><span class="p">(</span><span class="nv">%eax</span><span class="p">)</span>
    <span class="nf">jne</span> <span class="no">reschedule</span>
    <span class="nf">cmpl</span> <span class="no">$0</span><span class="p">,</span><span class="no">counter</span><span class="p">(</span><span class="nv">%eax</span><span class="p">)</span>
    <span class="nf">je</span> <span class="no">reschedule</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">system_call</span></code> 用 <code class="docutils literal notranslate"><span class="pre">.globl</span></code> 修饰为其他函数可见。
<code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">sys_call_table(,%eax,4)</span></code> 之前是一些压栈保护，修改段选择子为内核段，
<code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">sys_call_table(,%eax,4)</span></code> 之后是看看是否需要重新调度，这些都与本实验没有直接关系，
此处只关心 <code class="docutils literal notranslate"><span class="pre">call</span> <span class="pre">sys_call_table(,%eax,4)</span></code> 这一句。
根据汇编寻址方法它实际上是：</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">call</span> <span class="no">sys_call_table</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="nv">%eax</span>   <span class="c"># 其中eax中放的是系统调用号，即__NR_xxxxxx</span>
</pre></div>
</div>
<p>显然， <code class="docutils literal notranslate"><span class="pre">sys_call_table</span></code> 一定是一个函数指针数组的起始地址，它定义在 <code class="docutils literal notranslate"><span class="pre">include/linux/sys.h</span></code> 中：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">fn_ptr</span> <span class="n">sys_call_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">sys_setup</span><span class="p">,</span> <span class="n">sys_exit</span><span class="p">,</span> <span class="n">sys_fork</span><span class="p">,</span> <span class="n">sys_read</span><span class="p">,</span> <span class="c1">// ……</span>
</pre></div>
</div>
<p>增加实验要求的系统调用，需要在这个函数表中增加两个函数引用—— <code class="docutils literal notranslate"><span class="pre">sys_iam</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys_whoami</span></code> 。
当然该函数在 <code class="docutils literal notranslate"><span class="pre">sys_call_table</span></code> 数组中的位置必须和 <code class="docutils literal notranslate"><span class="pre">__NR_xxxxxx</span></code> 的值对应上。
同时还要仿照此文件中前面各个系统调用的写法，加上：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kt">int</span> <span class="nf">sys_whoami</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">sys_iam</span><span class="p">();</span>
</pre></div>
</div>
<p>不然，编译会出错的。</p>
</div>
<div class="section" id="sys-iam-sys-whoami">
<h3>4.4.3. 实现 <code class="docutils literal notranslate"><span class="pre">sys_iam()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys_whoami()</span></code><a class="headerlink" href="#sys-iam-sys-whoami" title="永久链接至标题">¶</a></h3>
<p>添加系统调用的最后一步，是在内核中实现函数 <code class="docutils literal notranslate"><span class="pre">sys_iam()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys_whoami()</span></code> 。</p>
<p>每个系统调用都有一个 <code class="docutils literal notranslate"><span class="pre">sys_xxxxxx()</span></code> 与之对应，它们都是我们学习和模仿的好对象。
比如在 <code class="docutils literal notranslate"><span class="pre">fs/open.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">sys_close(int</span> <span class="pre">fd)</span></code> ：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">sys_close</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ……</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它没有什么特别的，都是实实在在地做 <code class="docutils literal notranslate"><span class="pre">close()</span></code> 该做的事情。所以只要自己创建一个文件： <code class="docutils literal notranslate"><span class="pre">kernel/who.c</span></code> ，然后实现两个函数就万事大吉了。</p>
</div>
<div class="section" id="makefile">
<h3>4.4.4. 修改 <code class="docutils literal notranslate"><span class="pre">Makefile</span></code><a class="headerlink" href="#makefile" title="永久链接至标题">¶</a></h3>
<p>要想让我们添加的 <code class="docutils literal notranslate"><span class="pre">kernel/who.c</span></code> 可以和其它Linux代码编译链接到一起，必须要修改 <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> 文件。
<code class="docutils literal notranslate"><span class="pre">Makefile</span></code> 里记录的是所有源程序文件的编译、链接规则，《注释》 <code class="docutils literal notranslate"><span class="pre">3.6</span></code> 节有简略介绍。
我们之所以简单地运行 <code class="docutils literal notranslate"><span class="pre">make</span></code> 就可以编译整个代码树，是因为 <code class="docutils literal notranslate"><span class="pre">make</span></code> 完全按照 <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> 里的指示工作。</p>
<p><code class="docutils literal notranslate"><span class="pre">Makefile</span></code> 在代码树中有很多，分别负责不同模块的编译工作。我们要修改的是 <code class="docutils literal notranslate"><span class="pre">kernel/Makefile</span></code> 。
需要修改两处。一处是：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">OBJS</span>  <span class="o">=</span> sched.o system_call.o traps.o asm.o fork.o <span class="se">\</span>
        panic.o printk.o vsprintf.o sys.o exit.o <span class="se">\</span>
        signal.o mktime.o
</pre></div>
</div>
<p>改为：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">OBJS</span>  <span class="o">=</span> sched.o system_call.o traps.o asm.o fork.o <span class="se">\</span>
        panic.o printk.o vsprintf.o sys.o exit.o <span class="se">\</span>
        signal.o mktime.o who.o
</pre></div>
</div>
<p>另一处：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="c">### Dependencies:</span>
<span class="nf">exit.s exit.o</span><span class="o">:</span> <span class="n">exit</span>.<span class="n">c</span> ../<span class="n">include</span>/<span class="n">errno</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">signal</span>.<span class="n">h</span> \
  ../<span class="n">include</span>/<span class="n">sys</span>/<span class="n">types</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">sys</span>/<span class="n">wait</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">sched</span>.<span class="n">h</span> \
  ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">head</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">fs</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">mm</span>.<span class="n">h</span> \
  ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">kernel</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">tty</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">termios</span>.<span class="n">h</span> \
  ../<span class="n">include</span>/<span class="n">asm</span>/<span class="n">segment</span>.<span class="n">h</span>
</pre></div>
</div>
<p>改为：</p>
<div class="highlight-makefile notranslate"><div class="highlight"><pre><span></span><span class="c">### Dependencies:</span>
<span class="nf">who.s who.o</span><span class="o">:</span> <span class="n">who</span>.<span class="n">c</span> ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">kernel</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">unistd</span>.<span class="n">h</span>
<span class="nf">exit.s exit.o</span><span class="o">:</span> <span class="n">exit</span>.<span class="n">c</span> ../<span class="n">include</span>/<span class="n">errno</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">signal</span>.<span class="n">h</span> \
  ../<span class="n">include</span>/<span class="n">sys</span>/<span class="n">types</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">sys</span>/<span class="n">wait</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">sched</span>.<span class="n">h</span> \
  ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">head</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">fs</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">mm</span>.<span class="n">h</span> \
  ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">kernel</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">linux</span>/<span class="n">tty</span>.<span class="n">h</span> ../<span class="n">include</span>/<span class="n">termios</span>.<span class="n">h</span> \
  ../<span class="n">include</span>/<span class="n">asm</span>/<span class="n">segment</span>.<span class="n">h</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Makefile</span></code> 修改后，和往常一样 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">all</span></code> 就能自动把 <code class="docutils literal notranslate"><span class="pre">who.c</span></code> 加入到内核中了。
如果编译时提示 <code class="docutils literal notranslate"><span class="pre">who.c</span></code> 有错误，就说明修改生效了。
所以，有意或无意地制造一两个错误也不完全是坏事，至少能证明 <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> 是对的。</p>
</div>
<div class="section" id="printk">
<h3>4.4.5. 用 <code class="docutils literal notranslate"><span class="pre">printk()</span></code> 调试内核<a class="headerlink" href="#printk" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">oslab</span></code> 实验环境提供了基于 <code class="docutils literal notranslate"><span class="pre">C</span></code> 语言和汇编语言的两种调试手段。
除此之外，适当地向屏幕输出一些程序运行状态的信息，也是一种很高效、便捷的调试方法，
有时甚至是唯一的方法，被称为 <code class="docutils literal notranslate"><span class="pre">printf</span></code> 法。</p>
<p>要知道到， <code class="docutils literal notranslate"><span class="pre">printf()</span></code> 是一个只能在用户模式下执行的函数，而系统调用是在内核模式中运行，
所以 <code class="docutils literal notranslate"><span class="pre">printf()</span></code> 不可用，要用 <code class="docutils literal notranslate"><span class="pre">printk()</span></code> 。
它和 <code class="docutils literal notranslate"><span class="pre">printf</span></code> 的接口和功能基本相同，只是代码上有一点点不同。
<code class="docutils literal notranslate"><span class="pre">printk()</span></code> 需要特别处理一下 <code class="docutils literal notranslate"><span class="pre">fs</span></code> 寄存器，它是专用于用户模式的段寄存器。
看一看 <code class="docutils literal notranslate"><span class="pre">printk</span></code> 的代码（在 <code class="docutils literal notranslate"><span class="pre">kernel/printk.c</span></code> 中）就知道了：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="c1">// ……</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;push %%fs</span><span class="se">\n\t</span><span class="s">&quot;</span>
            <span class="s">&quot;push %%ds</span><span class="se">\n\t</span><span class="s">&quot;</span>
            <span class="s">&quot;pop %%fs</span><span class="se">\n\t</span><span class="s">&quot;</span>
            <span class="s">&quot;pushl %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
            <span class="s">&quot;pushl $buf</span><span class="se">\n\t</span><span class="s">&quot;</span>
            <span class="s">&quot;pushl $0</span><span class="se">\n\t</span><span class="s">&quot;</span>
            <span class="s">&quot;call tty_write</span><span class="se">\n\t</span><span class="s">&quot;</span>
            <span class="s">&quot;addl $8,%%esp</span><span class="se">\n\t</span><span class="s">&quot;</span>
            <span class="s">&quot;popl %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
            <span class="s">&quot;pop %%fs&quot;</span>
            <span class="o">::</span><span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="s">&quot;ax&quot;</span><span class="p">,</span><span class="s">&quot;cx&quot;</span><span class="p">,</span><span class="s">&quot;dx&quot;</span><span class="p">);</span>
   <span class="c1">// ……</span>
<span class="p">}</span>
</pre></div>
</div>
<p>显然， <code class="docutils literal notranslate"><span class="pre">printk()</span></code> 首先 <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">%fs</span></code> 保存这个指向用户段的寄存器，在最后 <code class="docutils literal notranslate"><span class="pre">pop</span> <span class="pre">%fs</span></code> 将其恢复，
<code class="docutils literal notranslate"><span class="pre">printk</span></code> 的核心仍然是调用 <code class="docutils literal notranslate"><span class="pre">tty_write()</span></code> 。
查看 <code class="docutils literal notranslate"><span class="pre">printf()</span></code> 可以看到，它最终也要落实到这个函数上。</p>
</div>
<div class="section" id="id9">
<h3>4.4.6. 编写测试程序<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>激动地运行一下由你亲手修改过的 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span> <span class="pre">pro++</span></code> ！然后编写一个简单的应用程序进行测试。
比如在 <code class="docutils literal notranslate"><span class="pre">sys_iam()</span></code> 中向终端 <code class="docutils literal notranslate"><span class="pre">printk()</span></code> 一些信息，让应用程序调用 <code class="docutils literal notranslate"><span class="pre">iam()</span></code> ，从结果可以看出系统调用是否被真的调用到了。</p>
<p>可以直接在Linux 0.11环境下用 <code class="docutils literal notranslate"><span class="pre">vi</span></code> 编写（别忘了经常执行 <code class="docutils literal notranslate"><span class="pre">sync</span></code> 以确保内存缓冲区的数据写入磁盘），
也可以在 <code class="docutils literal notranslate"><span class="pre">Ubuntu</span></code> 下编完后再传到 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span></code> 下。无论如何，最终都必须在 <code class="docutils literal notranslate"><span class="pre">Linux</span> <span class="pre">0.11</span></code> 下编译。编译命令是：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">gcc -o iam iam.c -Wall</span>
</pre></div></div><p><code class="docutils literal notranslate"><span class="pre">gcc</span></code> 的 <code class="docutils literal notranslate"><span class="pre">-Wall</span></code> 参数是给出所有的编译警告信息， <code class="docutils literal notranslate"><span class="pre">-o</span></code> 参数指定生成的执行文件名是 <code class="docutils literal notranslate"><span class="pre">iam</span></code>  ，用下面命令运行它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">./iam</span>
</pre></div></div><p>如果如愿输出了你的信息，就说明你添加的系统调用生效了。否则，就还要继续调试，祝你好运！</p>
</div>
<div class="section" id="id10">
<h3>4.4.7. 在用户态和核心态之间传递数据<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>指针参数传递的是应用程序所在地址空间的逻辑地址，在内核中如果直接访问这个地址，访问到的是内核空间中的数据，不会是用户空间的。所以这里还需要一点儿特殊工作，才能在内核中从用户空间得到数据。</p>
<p>要实现的两个系统调用参数中都有字符串指针，
非常象 <code class="docutils literal notranslate"><span class="pre">open(char</span> <span class="pre">*filename,</span> <span class="pre">……)</span></code> ，所以我们看一下 <code class="docutils literal notranslate"><span class="pre">open()</span></code> 系统调用是如何处理的。</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="c1">// ……</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">&quot;int $0x80&quot;</span>
            <span class="o">:</span><span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="o">:</span><span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">__NR_open</span><span class="p">),</span><span class="s">&quot;b&quot;</span> <span class="p">(</span><span class="n">filename</span><span class="p">),</span><span class="s">&quot;c&quot;</span> <span class="p">(</span><span class="n">flag</span><span class="p">),</span>
            <span class="s">&quot;d&quot;</span> <span class="p">(</span><span class="n">va_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span><span class="kt">int</span><span class="p">)));</span>
    <span class="c1">// ……</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可以看出，系统调用是用 <code class="docutils literal notranslate"><span class="pre">eax</span></code> 、 <code class="docutils literal notranslate"><span class="pre">ebx</span></code> 、 <code class="docutils literal notranslate"><span class="pre">ecx</span></code> 、 <code class="docutils literal notranslate"><span class="pre">edx</span></code> 寄存器来传递参数的。
其中 <code class="docutils literal notranslate"><span class="pre">eax</span></code> 传递了系统调用号，而 <code class="docutils literal notranslate"><span class="pre">ebx</span></code> 、 <code class="docutils literal notranslate"><span class="pre">ecx</span></code> 、 <code class="docutils literal notranslate"><span class="pre">edx</span></code> 是用来传递函数的参数的，其中 <code class="docutils literal notranslate"><span class="pre">ebx</span></code> 对应第一个参数， <code class="docutils literal notranslate"><span class="pre">ecx</span></code> 对应第二个参数，
依此类推。如 <code class="docutils literal notranslate"><span class="pre">open</span></code> 所传递的文件名指针是由 <code class="docutils literal notranslate"><span class="pre">ebx</span></code> 传递的，也即进入内核后，通过 <code class="docutils literal notranslate"><span class="pre">ebx</span></code> 取出文件名字符串。
<code class="docutils literal notranslate"><span class="pre">open</span></code> 的 <code class="docutils literal notranslate"><span class="pre">ebx</span></code> 指向的数据在用户空间，而当前执行的是内核空间的代码，
如何在用户态和核心态之间传递数据？接下来我们继续看看 <code class="docutils literal notranslate"><span class="pre">open</span></code> 的处理：</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nl">system_call:</span> <span class="c"># 所有的系统调用都从system_call开始</span>
    <span class="c"># ……</span>
    <span class="nf">pushl</span> <span class="nv">%edx</span>
    <span class="nf">pushl</span> <span class="nv">%ecx</span>
    <span class="nf">pushl</span> <span class="nv">%ebx</span>                 <span class="c"># push %ebx,%ecx,%edx，这是传递给系统调用的参数</span>
    <span class="nf">movl</span> <span class="no">$0x10</span><span class="p">,</span><span class="nv">%edx</span>            <span class="c"># 让ds,es指向GDT，指向核心地址空间</span>
    <span class="nf">mov</span> <span class="nv">%dx</span><span class="p">,</span><span class="nv">%ds</span>
    <span class="nf">mov</span> <span class="nv">%dx</span><span class="p">,</span><span class="nv">%es</span>
    <span class="nf">movl</span> <span class="no">$0x17</span><span class="p">,</span><span class="nv">%edx</span>            <span class="c"># 让fs指向的是LDT，指向用户地址空间</span>
    <span class="nf">mov</span> <span class="nv">%dx</span><span class="p">,</span><span class="nv">%fs</span>
    <span class="nf">call</span> <span class="no">sys_call_table</span><span class="p">(,</span><span class="nv">%eax</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>    <span class="c"># 即call sys_open</span>
</pre></div>
</div>
<p>由上面的代码可以看出，获取用户地址空间（用户数据段）中的数据依靠的就是段寄存器 <code class="docutils literal notranslate"><span class="pre">fs</span></code> ，
下面该转到 <code class="docutils literal notranslate"><span class="pre">sys_open</span></code> 执行了，在 <code class="docutils literal notranslate"><span class="pre">fs/open.c</span></code> 文件中：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">sys_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>  <span class="c1">//filename这些参数从哪里来？</span>
<span class="cm">/*是否记得上面的pushl %edx,    pushl %ecx,    pushl %ebx？</span>
<span class="cm">  实际上一个C语言函数调用另一个C语言函数时，编译时就是将要</span>
<span class="cm">  传递的参数压入栈中（第一个参数最后压，…），然后call …，</span>
<span class="cm">  所以汇编程序调用C函数时，需要自己编写这些参数压栈的代码…*/</span>
<span class="p">{</span>
    <span class="c1">// ……</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="o">=</span><span class="n">open_namei</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">flag</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="o">&amp;</span><span class="n">inode</span><span class="p">))</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ……</span>
    <span class="p">}</span>
    <span class="c1">// ……</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它将参数传给了 <code class="docutils literal notranslate"><span class="pre">open_namei()</span></code> 。
再沿着 <code class="docutils literal notranslate"><span class="pre">open_namei()</span></code> 继续查找，文件名先后又被传给 <code class="docutils literal notranslate"><span class="pre">dir_namei()</span></code> 、 <code class="docutils literal notranslate"><span class="pre">get_dir()</span></code> 。
在 <code class="docutils literal notranslate"><span class="pre">get_dir()</span></code> 中可以看到：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">m_inode</span> <span class="o">*</span> <span class="nf">get_dir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">pathname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ……</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">=</span><span class="n">get_fs_byte</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span><span class="o">==</span><span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ……</span>
    <span class="p">}</span>
    <span class="c1">// ……</span>
<span class="p">}</span>
</pre></div>
</div>
<p>处理方法就很显然了：用 <code class="docutils literal notranslate"><span class="pre">get_fs_byte()</span></code> 获得一个字节的用户空间中的数据。
所以，在实现 <code class="docutils literal notranslate"><span class="pre">iam()</span></code> 时，调用 <code class="docutils literal notranslate"><span class="pre">get_fs_byte()</span></code> 即可。
但如何实现 <code class="docutils literal notranslate"><span class="pre">whoami()</span></code> 呢？即如何实现从核心态拷贝数据到用心态内存空间中呢？
猜一猜，是否有 <code class="docutils literal notranslate"><span class="pre">put_fs_byte()</span></code> ？有！看一看 <code class="docutils literal notranslate"><span class="pre">include/asm/segment.h</span></code> ：</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">get_fs_byte</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="k">register</span> <span class="kt">char</span> <span class="n">_v</span><span class="p">;</span>
    <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;movb %%fs:%1,%0&quot;</span><span class="o">:</span><span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">_v</span><span class="p">)</span><span class="o">:</span><span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">_v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_fs_byte</span><span class="p">(</span><span class="kt">char</span> <span class="n">val</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;movb %0,%%fs:%1&quot;</span><span class="o">::</span><span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">),</span><span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>他俩以及所有 <code class="docutils literal notranslate"><span class="pre">put_fs_xxx()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">get_fs_xxx()</span></code> 都是用户空间和内核空间之间的桥梁，在后面的实验中还要经常用到。</p>
</div>
<div class="section" id="id11">
<h3>4.4.8. 运行脚本程序<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>Linux的一大特色是可以编写功能强大的 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 脚本，提高工作效率。
本实验的部分评分工作由脚本 <code class="docutils literal notranslate"><span class="pre">testlab2.sh</span></code> 完成。它的功能是测试 <code class="docutils literal notranslate"><span class="pre">iam.c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">whoami.c</span></code> 。</p>
<p>首先将 <code class="docutils literal notranslate"><span class="pre">iam.c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">whoami.c</span></code> 分别编译成 <code class="docutils literal notranslate"><span class="pre">iam</span></code> 和 <code class="docutils literal notranslate"><span class="pre">whoami</span></code> ，然后将 <code class="docutils literal notranslate"><span class="pre">testlab2.sh</span></code>
拷贝到同一目录下。
用下面命令为此脚本增加执行权限：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">chmod +x testlab2.sh</span>
</pre></div></div><p>然后运行之：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="prompt1">./testlab2.sh</span>
</pre></div></div><p>根据输出，可知 <code class="docutils literal notranslate"><span class="pre">iam.c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">whoami.c</span></code> 的得分。</p>
</div>
<div class="section" id="errno">
<h3>4.4.9. errno<a class="headerlink" href="#errno" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">errno</span></code> 是一种传统的错误代码返回机制。当一个函数调用出错时，通常会返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 给调用者。
但 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 只能说明出错，不能说明错是什么。为解决此问题，全局变量 <code class="docutils literal notranslate"><span class="pre">errno</span></code> 登场了。
错误值被存放到 <code class="docutils literal notranslate"><span class="pre">errno</span></code> 中，于是调用者就可以通过判断 <code class="docutils literal notranslate"><span class="pre">errno</span></code> 来决定如何应对错误了。
各种系统对 <code class="docutils literal notranslate"><span class="pre">errno</span></code> 的值的含义都有标准定义。
Linux下用 <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">errno</span></code> 可以看到这些定义。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lab03.html" class="btn btn-neutral float-right" title="5. 进程运行轨迹的跟踪与统计" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lab01.html" class="btn btn-neutral float-left" title="3. 操作系统的引导" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019-2022, Dr. GuoJun LIU. All Rights Reserved.

    </p>
  </div>
 
	<script type="text/javascript">
		document.write(unescape("%3Cspan id='cnzz_stat_icon_1278706363'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1278706363%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));	
	</script>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>