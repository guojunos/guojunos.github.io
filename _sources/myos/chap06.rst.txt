计算机引导程序
==============

为什么上来第一句要jmp
---------------------

要改变cs的值为0x7c00，这样ip的偏移就能和程序的一一对上了。
然后再设置相应ds，ss，和栈的大小。

为什么不把head.s直接移动到0x0000处
----------------------------------

因为0x0000处要放BIOS的中断程序，例如，int 0x13

如何查看实模式的中断程序
------------------------

举例，int
0x13，并进行跟踪调试，让学生自己计算此时中断向量号的内存地址，然后，找
出对应中断向量，每个中断向量分别对应4个字节，高2位给CS，低2位给IP。

为什么要把head.s从0x10000处，移动到0x0处
----------------------------------------

重新布置自己的内核，不是必须的，但是这么做会更容易后面的操作。进入实模式后，代码
直接从0x0处运行。

如何装载idt与gdt表
------------------

解释gdt与idt的结构，6个字节的含义

gdt的表项是怎么存的，也是放在内存中

解释gdt的第1项和第2项的内容，参照gdt描述符结构进行解释

为什么一定要在实模式下，先创建gdt与idt表，才进入到保护模式

解释如何从实模式切换到保护模式
------------------------------

设置gdt与idt等

设置cr0，lmsw是一个隐操作

将os代码移动到相应位置

解释jmpi 0,8
------------

怎么就跳到了保护模式下

跳到哪？查cs，ip，与实模式下查法一样吗？

跳到head.s处去执行，事先放好，所以，才要在实模式下挪来挪去，并设置好
gdt表

跳完以后，gdt表仍然保留在0x7c51那个地方，gdtr没有变化

为什么结尾要有0xaa55？
----------------------

合法引导的第一个扇区，必须这样结尾，也称为花码
